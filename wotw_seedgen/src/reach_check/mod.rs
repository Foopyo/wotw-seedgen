use crate::{Inventory, log};
use crate::settings::{UniverseSettings, WorldSettings};
use crate::util;
use crate::world::World;
use crate::world::graph::{Graph, Node};

/// Returns all the reachable item locations on a given inventory
/// 
/// `seed_file` should be a seed file generated by [`generate_seed`](crate::generator::generate_seed)
pub fn reach_check<'graph>(inventory: Inventory, graph: &'graph Graph, seed_file: &str, set_nodes: &[String]) -> Result<Vec<&'graph Node>, String> {
    let universe_settings = UniverseSettings::from_seed(seed_file).unwrap_or_else(|| Err("Failed to read settings from seed".into()))?;
    let world_settings = WorldSettings::from_seed(seed_file, universe_settings).unwrap_or_else(|| Err("Failed to read world index from seed".into()))?;
    let mut world = World::new(graph, &world_settings);

    world.player.inventory.merge(inventory);

    for set in set_nodes {
        set_node(&mut world, set);
    }
    apply_sets(&mut world, seed_file)?;

    let spawn_identifier = util::spawn_from_seed(seed_file)?;
    let spawn = world.graph.find_spawn(&spawn_identifier)?;

    let mut reached = world.graph.reached_locations(&world.player, spawn, world.uber_states(), &world.sets);
    reached.retain(|&node| node.can_place());

    Ok(reached)
}

fn set_node(world: &mut World, identifier: &str) {
    let node = world.graph.nodes.iter().find(|&node| node.identifier() == identifier);

    if let Some(found_node) = node {
        log::trace!("Setting state {}", identifier);
        world.sets.push(found_node.index());
    } else {
        log::warning!("State {} not found", identifier);
    }
}

fn apply_sets(world: &mut World, seed_file: &str) -> Result<(), String> {
    for line in seed_file.lines() {
        if let Some(sets) = line.strip_prefix("// Sets: ") {
            if !sets.is_empty() {
                for identifier in sets.split(',').map(str::trim) {
                    set_node(world, identifier);
                };
            }

            break;
        }
    }

    Ok(())
}
